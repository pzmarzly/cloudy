#!/bin/bash
set -e

# Constants

GLOBAL_CONF=~/.cloudy
LOCAL_CONF=.cloudy
LOCAL_INIT=.cloudy-init.sh
LOCAL_LOCKFILE=.cloudy-server-running~

# Defaults

KEY_PATH=~/.ssh/id_rsa
REGION=fra1
SIZE=s-1vcpu-1gb
FILE_CHANNEL_REUSE=1
SEND_CLOUDY=0
SEND_GITIGNORE=0
SEND_GIT=0

# Load config

if [ -f $GLOBAL_CONF ]; then
    . $GLOBAL_CONF
fi

if [ -f $LOCAL_CONF ]; then
    . $LOCAL_CONF
fi

if [ -f $LOCAL_LOCKFILE ]; then
    ID=$(cat $LOCAL_LOCKFILE | cut -f1 -d' ')
fi

if [ -f $LOCAL_LOCKFILE ]; then
    IP=$(cat $LOCAL_LOCKFILE | cut -f2 -d' ')
fi

# Utilities

assert_lockfile_present(){
    if [ ! -f $LOCAL_LOCKFILE ]; then
        echo "Server not running!"
        echo "$LOCAL_LOCKFILE was not found. Start with \"cloudy init\"."
        exit 1
    fi
}

m_ssh(){
    FLAGS=("-o" "ControlMaster=auto"
        "-o" "ControlPersist=600"
        "-o" "ControlPath=~/.ssh/master-$1"
        "-i" "$KEY_PATH"
        "root@$2" "$3")
    ssh "${FLAGS[@]}"
}

m_rsync(){
    FLAGS=("-r" "-t" "-p") # t - timestamps, p - permissions

    if [ "$SEND_CLOUDY" == "0" ]; then
        FLAGS+=("--exclude=.cloudy*")
    fi
    if [ "$SEND_GITIGNORE" == "0" ]; then
        FLAGS+=("--filter=:- .gitignore")
    fi
    if [ "$SEND_GIT" == 0]; then
        FLAGS+=("--exclude=.git*")
    fi

    if [ "$FILE_CHANNEL_REUSE" != "0" ]; then
        FLAGS+=("-e"
            "ssh -o ControlMaster=auto -o ControlPersist=600 -o ControlPath=~/.ssh/master-$1 -i $KEY_PATH")
    fi

    FLAGS+=("." "root@$2:~/cloudy/")

    rsync "${FLAGS[@]}"
}

m_scp(){
    FLAGS=("-p") # preserve timestamps and modes
    if [ "$FILE_CHANNEL_REUSE" == "1" ]; then
        FLAGS+=("-o" "ControlMaster=auto"
        "-o" "ControlPersist=600"
        "-o" "ControlPath=~/.ssh/master-$1"
        "-i" "$KEY_PATH")
    fi
    FLAGS+=("root@$2:~/cloudy/$3" "./$3")

    OUTPUT_DIR=$(dirname $3)
    mkdir -p $OUTPUT_DIR

    scp "${FLAGS[@]}"
}

# Subcommands

print_help(){
    echo "Cloudy - set up VPS and run your workflow on it."
    echo "  Sends your current working directory, by default"
    echo "  without .gitignore-d files and .git. See project"
    echo "  website for config."
    echo ""
    echo "Subcommands:"
    echo "  init - starts remote server"
    echo "  reinit - executes $LOCAL_INIT on existing server"
    echo "  cmd <COMMAND...> - runs command on remote server"
    echo "  get <PATH> - downloads file off existing server"
    echo "  stop - stops server"
}

cmd_init(){
    if [ -f $LOCAL_LOCKFILE ]; then
        echo "Server already running!"
        echo "Check doctl and remove $LOCAL_LOCKFILE if it is not."
        exit 1
    fi

    KEY=$(awk "{print \$2}" "$KEY_PATH.pub" \
        | openssl base64 -d \
        | openssl md5 \
        | cut -f2 -d' ' \
        | sed 's/../&:/g;s/:$//')

    RANDOM_ID=`head /dev/urandom | tr -dc A-Za-z | head -c16`
    ID=cloudy-$RANDOM_ID
    echo "Starting $ID..."

    IP=$(doctl compute droplet create $ID \
        --region $REGION \
        --image ubuntu-18-04-x64 \
        --size $SIZE \
        --ssh-keys $KEY \
        --output=json \
        --wait \
        | python3 -c "import sys, json; print(json.load(sys.stdin)[0]['networks']['v4'][0]['ip_address'])")

    echo "Droplet started."

    # TODO: maybe DO will start pushing fingerprint via API one day
    ssh-keyscan $IP >> ~/.ssh/known_hosts

    echo "Setting up server..."

    # TODO: WARN: when updating Ubuntu, check if this fix is still necessary
    m_ssh $ID $IP "sed -i -e 's/mesg n .*true/tty -s \&\& mesg n/g' /root/.profile"

    m_rsync $ID $IP &

    if [ -f $LOCAL_INIT ]; then
        m_ssh $ID $IP " apt-get update"
        m_ssh $ID $IP " bash -ls" < $LOCAL_INIT
    fi

    echo "Waiting for files to finish transferring..."
    wait

    echo "Done."

    echo "$ID $IP" > $LOCAL_LOCKFILE
}

cmd_reinit(){
    assert_lockfile_present
    if [ ! -f $LOCAL_INIT ]; then
        echo "Did not find $LOCAL_INIT!"
        exit 1
    fi
    m_ssh $ID $IP " apt-get update"
    m_ssh $ID $IP " bash -ls" < $LOCAL_INIT
}

cmd_cmd(){
    assert_lockfile_present
    m_rsync $ID $IP
    m_ssh $ID $IP " bash -ls -c \" cd cloudy; $@\""
}

cmd_get(){
    assert_lockfile_present
    m_scp $ID $IP $1
}

cmd_stop(){
    assert_lockfile_present
    rm $LOCAL_LOCKFILE
    doctl compute droplet delete $ID -f
}

subcommand=$1
case $subcommand in
    "" | "-h" | "--help")
        print_help
        ;;
    *)
        shift
        cmd_${subcommand} $@
        if [ $? = 127 ]; then
            echo "Unknown subcommand."
            echo "Run with \"--help\" for help."
            exit 1
        fi
        ;;
esac
exit 0
