#!/bin/bash
set -e

# Constants

GLOBAL_CONF=~/.cloudy
GLOBAL_INIT=~/.cloudy-init.sh
LOCAL_CONF=.cloudy
LOCAL_INIT=.cloudy-init.sh
LOCAL_LOCKFILE=.cloudy-server-running~

# Defaults

KEY_PATH=~/.ssh/id_rsa
REGION=fra1
SIZE=s-1vcpu-1gb
FILE_CHANNEL_REUSE=1
SEND_CLOUDY=0
SEND_GITIGNORE=0
SEND_GIT=0

# Load config

if [ -f $GLOBAL_CONF ]; then
    . $GLOBAL_CONF
fi

if [ -f $LOCAL_CONF ]; then
    . $LOCAL_CONF
fi

if [ -f $LOCAL_LOCKFILE ]; then
    ID=$(cat $LOCAL_LOCKFILE | cut -f1 -d' ')
fi

if [ -f $LOCAL_LOCKFILE ]; then
    IP=$(cat $LOCAL_LOCKFILE | cut -f2 -d' ')
fi

# Utilities

assert_lockfile_present(){
    if [ ! -f $LOCAL_LOCKFILE ]; then
        echo "Server not running!"
        echo "$LOCAL_LOCKFILE was not found. Start with \"cloudy init\"."
        exit 1
    fi
}

assert_lockfile_absent(){
    if [ -f $LOCAL_LOCKFILE ]; then
        echo "Server already running!"
        echo "Check server status and remove $LOCAL_LOCKFILE if it is not."
        exit 1
    fi
}

# Network utilities

m_ssh(){
    FLAGS=("-o" "ControlMaster=auto"
        "-o" "ControlPersist=600"
        "-o" "ControlPath=~/.ssh/master-$1"
        "-i" "$KEY_PATH"
        "root@$2" "$3")
    ssh "${FLAGS[@]}"
}

m_rsync(){
    FLAGS=("-r" "-t" "-p") # t - timestamps, p - permissions

    if [ "$SEND_CLOUDY" == "0" ]; then
        FLAGS+=("--exclude=.cloudy*")
    fi
    if [ "$SEND_GITIGNORE" == "0" ]; then
        FLAGS+=("--filter=:- .gitignore")
    fi
    if [ "$SEND_GIT" == "0" ]; then
        FLAGS+=("--exclude=.git*")
    fi

    if [ "$FILE_CHANNEL_REUSE" != "0" ]; then
        FLAGS+=("-e"
            "ssh -o ControlMaster=auto -o ControlPersist=600 -o ControlPath=~/.ssh/master-$1 -i $KEY_PATH")
    fi

    FLAGS+=("." "root@$2:~/cloudy/")

    rsync "${FLAGS[@]}"
}

m_scp(){
    FLAGS=("-p") # preserve timestamps and modes
    if [ "$FILE_CHANNEL_REUSE" == "1" ]; then
        FLAGS+=("-o" "ControlMaster=auto"
        "-o" "ControlPersist=600"
        "-o" "ControlPath=~/.ssh/master-$1"
        "-i" "$KEY_PATH")
    fi
    FLAGS+=("root@$2:~/cloudy/$3" "./$3")

    OUTPUT_DIR=$(dirname $3)
    mkdir -p $OUTPUT_DIR

    scp "${FLAGS[@]}"
}

# Subcommands

## Help

print_help(){
    echo "Cloudy - set up VPS and run your workflow on it. Sends your current working"
    echo "  directory, by default without .gitignore-d files and .git. See project's"
    echo "  Github page for config."
    echo ""
    echo "Subcommands - init:"
    echo "  order - starts new server on DigitalOcean"
    echo "  use <[USER@]IP or NAME> - connects to server. NAME must be in ~/.ssh/config"
    echo "Subcommands - control:"
    echo "  reinit - reexecutes $LOCAL_INIT on server"
    echo "  cmd <COMMAND...> - runs command on server"
    echo "  ssh - opens shell on server"
    echo "  get <PATH> - downloads file off server"
    echo "  stop - stops server"
}

## Init

random_id(){
    head /dev/urandom | tr -dc A-Za-z | head -c16
}

run_init(){
    if [ -f $GLOBAL_INIT ] || [ -f $LOCAL_INIT ]; then
        m_ssh $ID $IP " apt-get update"
    fi

    if [ -f $GLOBAL_INIT ]; then
        m_ssh $ID $IP " bash -ls" < $GLOBAL_INIT
    fi

    if [ -f $LOCAL_INIT ]; then
        m_ssh $ID $IP " bash -ls" < $LOCAL_INIT
    fi
}

server_setup(){
    echo "Setting up server..."

    # TODO: WARN: when updating Ubuntu, check if this fix is still necessary
    m_ssh $ID $IP "sed -i -e 's/mesg n .*true/tty -s \&\& mesg n/g' /root/.profile | true"

    m_rsync $ID $IP &
    run_init

    echo "Waiting for files to finish transferring..."
    wait

    echo "Done."

    echo "$ID $IP" > $LOCAL_LOCKFILE
}

cmd_order(){
    assert_lockfile_absent

    KEY=$(awk "{print \$2}" "$KEY_PATH.pub" \
        | openssl base64 -d \
        | openssl md5 \
        | cut -f2 -d' ' \
        | sed 's/../&:/g;s/:$//')

    ID=cloudy-droplet-`random_id`
    echo "Ordering $ID, size = $SIZE, region = $REGION, key = $KEY..."

    IP=$(doctl compute droplet create $ID \
        --region $REGION \
        --image ubuntu-18-04-x64 \
        --size $SIZE \
        --ssh-keys "$KEY" \
        --output=json \
        --wait \
        | python3 -c "import sys, json; print(json.load(sys.stdin)[0]['networks']['v4'][0]['ip_address'])")

    echo "Droplet started."

    # TODO: maybe DO will start pushing fingerprint via API one day
    ssh-keyscan $IP >> ~/.ssh/known_hosts

    server_setup
}

cmd_use(){
    assert_lockfile_absent
    IP=$1
    ID=cloudy-server-`random_id`
    echo "Using $ID..."
    server_setup
}

## Control

cmd_reinit(){
    assert_lockfile_present
    run_init
}

cmd_cmd(){
    assert_lockfile_present
    m_rsync $ID $IP
    CMD=" cd cloudy; $@"
    m_ssh $ID $IP " bash -ls -c \"$CMD\""
}

cmd_ssh(){
    assert_lockfile_present
    m_rsync $ID $IP
    m_ssh $ID $IP
}

cmd_get(){
    assert_lockfile_present
    if [ -z "$1" ]; then
        echo "Missing file path."
        exit 1
    fi
    m_scp $ID $IP $1
}

cmd_stop(){
    assert_lockfile_present
    rm $LOCAL_LOCKFILE
    doctl compute droplet delete $ID -f
}

subcommand=$1
case $subcommand in
    "" | "-h" | "--help")
        print_help
        ;;
    *)
        shift
        cmd_${subcommand} $@
        if [ $? = 127 ]; then
            echo "Unknown subcommand."
            echo "Run with \"--help\" for help."
            exit 1
        fi
        ;;
esac
exit 0
